rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Regras para a coleção de salas (rooms)
    match /rooms/{roomId} {
      
      // Permitir leitura para usuários autenticados
      allow read: if request.auth != null;
      
      // Permitir criação de sala apenas para usuários autenticados
      allow create: if request.auth != null &&
                       // O criador deve ser o usuário autenticado
                       request.resource.data.createdBy == request.auth.uid &&
                       // O criador deve estar na lista de jogadores
                       request.auth.uid in request.resource.data.players &&
                       // O criador deve ter a flag isCreator = true
                       request.resource.data.players[request.auth.uid].isCreator == true &&
                       // Status inicial deve ser 'waiting'
                       request.resource.data.status == 'waiting' &&
                       // Validar estrutura básica
                       request.resource.data.keys().hasAll(['createdAt', 'createdBy', 'players', 'status']) &&
                       // Máximo de 8 jogadores
                       request.resource.data.players.size() <= 8;
      
      // Permitir atualizações para usuários autenticados
      allow update: if request.auth != null &&
                       // Validações específicas para diferentes tipos de atualização
                       (
                         // 1. Adicionar novo jogador (simplificado)
                         isValidPlayerJoin() ||
                         // 2. Outros tipos de update (apenas se já estiver na sala)
                         (request.auth.uid in resource.data.players && (
                           isValidPlayerLeave() ||
                           isValidPuzzleSelection() ||
                           isValidGridUpdate() ||
                           isValidClueUpdate() ||
                           isValidRoomReset() ||
                           isValidGameMigration()
                         ))
                       );
      
      // Permitir delete apenas se for o último jogador ou criador
      allow delete: if request.auth != null &&
                       (resource.data.players.size() == 1 &&
                        request.auth.uid in resource.data.players);
                        
      // Funções auxiliares para validação
      function isValidPlayerJoin() {
        return (
          // Apenas adicionar jogadores, não remover
          request.resource.data.players.size() > resource.data.players.size() &&
          request.resource.data.players.size() <= 8 &&
          // Novo jogador deve ser o usuário autenticado
          request.auth.uid in request.resource.data.players &&
          request.resource.data.players[request.auth.uid].id == request.auth.uid &&
          // Não deve estar mudando outros campos além de players
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['players'])
        );
      }
      
      function isValidPlayerLeave() {
        return (
          // Removendo jogadores
          request.resource.data.players.size() < resource.data.players.size() &&
          // Apenas campos relacionados a jogadores e criador podem mudar
          onlyPlayersAndCreatorChanged() &&
          // Se removendo o criador, deve haver transferência de host válida
          (!isRemovingCreator() || hasValidHostTransfer())
        );
      }
      
      function isValidPuzzleSelection() {
        return (
          // Apenas o criador pode selecionar puzzle
          resource.data.players[request.auth.uid].isCreator == true &&
          // Campos que podem mudar: puzzleType, puzzleId, status, grid, cellAuthors, clues
          onlyPuzzleFieldsChanged() &&
          // Status deve mudar para 'playing'
          request.resource.data.status == 'playing' &&
          // puzzleType deve ser válido
          request.resource.data.puzzleType in ['classic', 'super'] &&
          // puzzleId deve ser número
          request.resource.data.puzzleId is int
        );
      }
      
      function isValidGridUpdate() {
        return (
          // Apenas campos grid e cellAuthors podem mudar
          onlyGridFieldsChanged() &&
          // Estado do jogo deve ser 'playing'
          resource.data.status == 'playing'
        );
      }
      
      function isValidClueUpdate() {
        return (
          // Apenas campo clues pode mudar
          onlyClueFieldsChanged() &&
          // Estado do jogo deve ser 'playing'
          resource.data.status == 'playing'
        );
      }
      
      function isValidRoomReset() {
        return (
          // Apenas o criador pode resetar
          resource.data.players[request.auth.uid].isCreator == true &&
          // Estado deve voltar para 'waiting'
          request.resource.data.status == 'waiting' &&
          // Campos de jogo devem ser limpos
          request.resource.data.puzzleType == null &&
          request.resource.data.puzzleId == null &&
          request.resource.data.grid == {} &&
          request.resource.data.cellAuthors == {} &&
          request.resource.data.clues == {}
        );
      }
      
      function isValidGameMigration() {
        return (
          // Jogador deve estar na sala
          request.auth.uid in resource.data.players &&
          // Campos de migração permitidos
          onlyMigrationFieldsChanged()
        );
      }
      
      // Funções auxiliares para verificar quais campos mudaram
      function onlyPlayersAndCreatorChanged() {
        return request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['players', 'createdBy']);
      }
      
      function onlyPuzzleFieldsChanged() {
        return request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['puzzleType', 'puzzleId', 'status', 'grid', 'cellAuthors', 'clues']);
      }
      
      function onlyGridFieldsChanged() {
        return request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['grid', 'cellAuthors']);
      }
      
      function onlyClueFieldsChanged() {
        return request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['clues']);
      }
      
      function onlyMigrationFieldsChanged() {
        return request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['grid', 'cellAuthors', 'clues', 'status', 'puzzleType', 'puzzleId', 'gameSettings', 'updatedAt']);
      }
      
      function isRemovingCreator() {
        return !(request.auth.uid in request.resource.data.players) &&
               resource.data.players[request.auth.uid].isCreator == true;
      }
      
      function hasValidHostTransfer() {
        // Se está removendo o criador, deve haver um novo criador válido
        return request.resource.data.createdBy != resource.data.createdBy &&
               request.resource.data.createdBy in request.resource.data.players &&
               request.resource.data.players[request.resource.data.createdBy].isCreator == true;
      }
    }
  }
}
